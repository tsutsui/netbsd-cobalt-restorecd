Index: sys/arch/cobalt/cobalt/autoconf.c
===================================================================
RCS file: /cvsroot/src/sys/arch/cobalt/cobalt/autoconf.c,v
retrieving revision 1.24.2.1
diff -u -r1.24.2.1 autoconf.c
--- sys/arch/cobalt/cobalt/autoconf.c	4 Nov 2007 16:30:55 -0000	1.24.2.1
+++ sys/arch/cobalt/cobalt/autoconf.c	2 Mar 2008 14:49:40 -0000
@@ -53,7 +53,7 @@
 
 	(void)splhigh();
 
-	icu_init();
+	intr_init();
 
 	if (config_rootfound("mainbus", NULL) == NULL)
 		panic("no mainbus found");
Index: sys/arch/cobalt/cobalt/machdep.c
===================================================================
RCS file: /cvsroot/src/sys/arch/cobalt/cobalt/machdep.c,v
retrieving revision 1.75.4.2
diff -u -r1.75.4.2 machdep.c
--- sys/arch/cobalt/cobalt/machdep.c	4 Nov 2007 16:30:55 -0000	1.75.4.2
+++ sys/arch/cobalt/cobalt/machdep.c	2 Mar 2008 14:49:41 -0000
@@ -419,363 +419,6 @@
 		;
 }
 
-
-#define NCPU_INT	6
-#define NICU_INT	16
-#define IRQ_SLAVE	2
-
-#define IO_ELCR		0x4d0
-#define IO_ELCRSIZE	2
-#define ELCR0		0
-#define ELCR1		1
-
-#define ICU1_READ(reg)		\
-    bus_space_read_1(icu_bst, icu1_bsh, (reg))
-#define ICU1_WRITE(reg, val)	\
-    bus_space_write_1(icu_bst, icu1_bsh, (reg), (val))
-#define ICU2_READ(reg)		\
-    bus_space_read_1(icu_bst, icu2_bsh, (reg))
-#define ICU2_WRITE(reg, val)	\
-    bus_space_write_1(icu_bst, icu2_bsh, (reg), (val))
-#define ELCR_READ(reg)		\
-    bus_space_read_1(icu_bst, elcr_bsh, (reg))
-#define ELCR_WRITE(reg, val)	\
-    bus_space_write_1(icu_bst, elcr_bsh, (reg), (val))
-
-const uint32_t mips_ipl_si_to_sr[_IPL_NSOFT] = {
-	MIPS_SOFT_INT_MASK_0,			/* IPL_SOFT */
-	MIPS_SOFT_INT_MASK_0,			/* IPL_SOFTCLOCK */
-	MIPS_SOFT_INT_MASK_1,			/* IPL_SOFTNET */
-	MIPS_SOFT_INT_MASK_1,			/* IPL_SOFTSERIAL */
-};
-
-u_int icu_imen;
-
-static bus_space_tag_t icu_bst;
-static bus_space_handle_t icu1_bsh, icu2_bsh, elcr_bsh;
-static struct cobalt_intrhand cpu_intrtab[NCPU_INT];
-static struct cobalt_intrhand icu_intrtab[NICU_INT];
-
-static int	icu_intr(void *);
-static void	icu_reinit_irqs(void);
-static u_int	icu_setmask(u_int);
-
-
-void
-icu_init(void)
-{
-
-	icu_bst = 0;	/* XXX unused on cobalt */
-	bus_space_map(icu_bst, PCIB_BASE + IO_ICU1, IO_ICUSIZE, 0, &icu1_bsh);
-	bus_space_map(icu_bst, PCIB_BASE + IO_ICU2, IO_ICUSIZE, 0, &icu2_bsh);
-	bus_space_map(icu_bst, PCIB_BASE + IO_ELCR, IO_ELCRSIZE, 0, &elcr_bsh);
-
-	/* Initialize master PIC */
-
-	/* reset; program device, four bytes */
-	ICU1_WRITE(PIC_ICW1, ICW1_SELECT | ICW1_IC4);
-	/* starting at this vector index */
-	ICU1_WRITE(PIC_ICW2, 0);			/* XXX */
-	/* slave on line 2 */
-	ICU1_WRITE(PIC_ICW3, ICW3_CASCADE(IRQ_SLAVE));
-	/* special fully nested mode, 8086 mode */
-	ICU1_WRITE(PIC_ICW4, ICW4_SFNM | ICW4_8086);
-	/* special mask mode */
-	ICU1_WRITE(PIC_OCW3, OCW3_SELECT | OCW3_SSMM | OCW3_SMM);
-	/* read IRR by default */
-	ICU1_WRITE(PIC_OCW3, OCW3_SELECT | OCW3_RR);
-
-	/* Initialize slave PIC */
-
-	/* reset; program device, four bytes */
-	ICU2_WRITE(PIC_ICW1, ICW1_SELECT | ICW1_IC4);
-	/* starting at this vector index */
-	ICU2_WRITE(PIC_ICW2, 8);			/* XXX */
-	/* slave connected to line 2 of master */
-	ICU2_WRITE(PIC_ICW3, ICW3_SIC(IRQ_SLAVE));
-	/* special fully nested mode, 8086 mode */
-	ICU2_WRITE(PIC_ICW4, ICW4_SFNM | ICW4_8086);
-	/* special mask mode */
-	ICU2_WRITE(PIC_OCW3, OCW3_SELECT | OCW3_SSMM | OCW3_SMM);
-	/* read IRR by default */
-	ICU2_WRITE(PIC_OCW3, OCW3_SELECT | OCW3_RR);
-
-	icu_setmask(0xffff);	/* mask all interrupts */
-
-	/* default to edge-triggered */
-	ELCR_WRITE(ELCR0, 0);
-	ELCR_WRITE(ELCR1, 0);
-
-	wbflush();
-
-	cpu_intr_establish(4, IPL_NONE, icu_intr, NULL);
-}
-
-void *
-icu_intr_establish(int irq, int type, int ipl, int (*func)(void *),
-    void *arg)
-{
-	struct cobalt_intrhand *ih;
-
-	ih = &icu_intrtab[irq];
-	if (ih->ih_func != NULL)
-		panic("icu_intr_establish(): irq %d is already in use", irq);
-
-	ih->ih_cookie_type = COBALT_COOKIE_TYPE_ICU;
-	ih->ih_func = func;
-	ih->ih_arg = arg;
-	ih->ih_type = type;
-	snprintf(ih->ih_evname, sizeof(ih->ih_evname), "irq %d", irq);
-	evcnt_attach_dynamic(&ih->ih_evcnt, EVCNT_TYPE_INTR, NULL, "icu",
-	    ih->ih_evname);
-
-	icu_reinit_irqs();
-
-	return ih;
-}
-
-void
-icu_intr_disestablish(void *cookie)
-{
-	struct cobalt_intrhand *ih = cookie;
-
-	if (ih->ih_cookie_type == COBALT_COOKIE_TYPE_ICU) {
-		ih->ih_func = NULL;
-		ih->ih_arg = NULL;
-		ih->ih_cookie_type = 0;
-		ih->ih_type = IST_NONE;
-		evcnt_detach(&ih->ih_evcnt);
-
-		icu_reinit_irqs();
-	}
-}
-
-void
-icu_reinit_irqs(void)
-{
-	u_int i, irqs, elcr;
-
-	/* unmask interrupts */
-	irqs = 0;
-	elcr = 0;
-	for (i = 0; i < NICU_INT; i++) {
-		if (icu_intrtab[i].ih_func) {
-			irqs |= 1 << i;
-			if (icu_intrtab[i].ih_type == IST_LEVEL)
-				elcr |= 1 << i;
-		}
-	}
-	if (irqs & 0xff00) /* any slave IRQs in use */
-		irqs |= 1 << IRQ_SLAVE;
-	icu_imen = ~irqs;
-
-	ICU1_WRITE(PIC_OCW1, icu_imen);
-	ICU2_WRITE(PIC_OCW1, icu_imen >> 8);
-
-	ELCR_WRITE(ELCR0, elcr);
-	ELCR_WRITE(ELCR1, elcr >> 8);
-}
-
-u_int
-icu_setmask(u_int mask)
-{
-	u_int old;
-
-	old = icu_imen;
-	icu_imen = mask;
-	ICU1_WRITE(PIC_OCW1, icu_imen);
-	ICU2_WRITE(PIC_OCW1, icu_imen >> 8);
-
-	return old;
-}
-
-int
-icu_intr(void *arg)
-{
-	struct cobalt_intrhand *ih;
-	int irq, handled;
-
-	handled = 0;
-
-	/* check requested irq */
-	ICU1_WRITE(PIC_OCW3, OCW3_SELECT | OCW3_POLL);
-	irq = ICU1_READ(PIC_OCW3);
-	if ((irq & OCW3_POLL_PENDING) == 0)
-		goto out;
-
-	irq = OCW3_POLL_IRQ(irq);
-	if (irq == IRQ_SLAVE) {
-		ICU2_WRITE(PIC_OCW3, OCW3_SELECT | OCW3_POLL);
-		irq = OCW3_POLL_IRQ(ICU2_READ(PIC_OCW3)) + 8;
-	}
-
-	ih = &icu_intrtab[irq];
-	if (__predict_false(ih->ih_func == NULL)) {
-		printf("icu_intr(): spurious interrupt (irq = %d)\n", irq);
-	} else if (__predict_true((*ih->ih_func)(ih->ih_arg))) {
-		ih->ih_evcnt.ev_count++;
-		handled = 1;
-	}
-
-	/* issue EOI to ack */
-	if (irq >= 8) {
-		ICU2_WRITE(PIC_OCW2,
-		    OCW2_SELECT | OCW2_SL | OCW2_EOI | OCW2_ILS(irq - 8));
-		irq = IRQ_SLAVE;
-	}
-	ICU1_WRITE(PIC_OCW2, OCW2_SELECT | OCW2_SL | OCW2_EOI | OCW2_ILS(irq));
-
- out:
-	return handled;
-}
-
-void *
-cpu_intr_establish(int level, int ipl, int (*func)(void *), void *arg)
-{
-	struct cobalt_intrhand *ih;
-
-	if (level < 0 || level >= NCPU_INT)
-		panic("invalid interrupt level");
-
-	ih = &cpu_intrtab[level];
-
-	if (ih->ih_func != NULL)
-		panic("cannot share CPU interrupts");
-
-	ih->ih_cookie_type = COBALT_COOKIE_TYPE_CPU;
-	ih->ih_func = func;
-	ih->ih_arg = arg;
-	snprintf(ih->ih_evname, sizeof(ih->ih_evname), "int %d", level);
-	evcnt_attach_dynamic(&ih->ih_evcnt, EVCNT_TYPE_INTR, NULL,
-	    "cpu", ih->ih_evname);
-
-	return ih;
-}
-
-void
-cpu_intr_disestablish(void *cookie)
-{
-	struct cobalt_intrhand *ih = cookie;
-
-	if (ih->ih_cookie_type == COBALT_COOKIE_TYPE_CPU) {
-		ih->ih_func = NULL;
-		ih->ih_arg = NULL;
-		ih->ih_cookie_type = 0;
-		evcnt_detach(&ih->ih_evcnt);
-	}
-}
-
-void
-cpu_intr(uint32_t status, uint32_t cause, uint32_t pc, uint32_t ipending)
-{
-	struct clockframe cf;
-	struct cobalt_intrhand *ih;
-
-	uvmexp.intrs++;
-
-	if (ipending & MIPS_INT_MASK_5) {
-
-		/* call the common MIPS3 clock interrupt handler */ 
-		cf.pc = pc;
-		cf.sr = status;
-
-		if ((status & MIPS_INT_MASK) == MIPS_INT_MASK) {
-			if ((ipending & MIPS_INT_MASK &
-			     ~MIPS_INT_MASK_5) == 0) {
-				/*
-				 * If all interrupts were enabled and
-				 * there is no pending interrupts,
-				 * set MIPS_SR_INT_IE so that
-				 * spllowersoftclock(9) in hardclock(9)
-				 * works properly.
-				 */
-				_splset(MIPS_SR_INT_IE);
-			} else {
-				/*
-				 * If there are any pending interrputs,
-				 * clear MIPS_SR_INT_IE in cf.sr so that
-				 * spllowersoftclock(9) in hardclock(9) will
-				 * not happen.
-				 */
-				cf.sr &= ~MIPS_SR_INT_IE;
-			}
-		}
-		mips3_clockintr(&cf);
-
-		cause &= ~MIPS_INT_MASK_5;
-	}
-	_splset((status & MIPS_INT_MASK_5) | MIPS_SR_INT_IE);
-
-	if (__predict_false(ipending & MIPS_INT_MASK_0)) {
-		/* GT64x11 timer0 */
-		volatile uint32_t *irq_src =
-		    (uint32_t *)MIPS_PHYS_TO_KSEG1(GT_BASE + GT_INTR_CAUSE);
-
-		if (__predict_true((*irq_src & T0EXP) != 0)) {
-			/* GT64x11 timer is no longer used for hardclock(9) */
-			*irq_src = 0;
-		}
-		cause &= ~MIPS_INT_MASK_0;
-	}
-	_splset((status & ~cause & MIPS_HARD_INT_MASK) | MIPS_SR_INT_IE);
-
-	if (ipending & MIPS_INT_MASK_3) {
-		/* 16650 serial */
-		ih = &cpu_intrtab[3];
-		if (__predict_true(ih->ih_func != NULL)) {
-			if (__predict_true((*ih->ih_func)(ih->ih_arg))) {
-				cause &= ~MIPS_INT_MASK_3;
-				ih->ih_evcnt.ev_count++;
-			}
-		}
-	}
-	_splset((status & ~cause & MIPS_HARD_INT_MASK) | MIPS_SR_INT_IE);
-
-	if (ipending & MIPS_INT_MASK_1) {
-		/* tulip primary */
-		ih = &cpu_intrtab[1];
-		if (__predict_true(ih->ih_func != NULL)) {
-			if (__predict_true((*ih->ih_func)(ih->ih_arg))) {
-				cause &= ~MIPS_INT_MASK_1;
-				ih->ih_evcnt.ev_count++;
-			}
-		}
-	}
-	if (ipending & MIPS_INT_MASK_2) {
-		/* tulip secondary */
-		ih = &cpu_intrtab[2];
-		if (__predict_true(ih->ih_func != NULL)) {
-			if (__predict_true((*ih->ih_func)(ih->ih_arg))) {
-				cause &= ~MIPS_INT_MASK_2;
-				ih->ih_evcnt.ev_count++;
-			}
-		}
-	}
-	_splset((status & ~cause & MIPS_HARD_INT_MASK) | MIPS_SR_INT_IE);
-
-	if (ipending & MIPS_INT_MASK_4) {
-		/* ICU interrupts */
-		ih = &cpu_intrtab[4];
-		if (__predict_true(ih->ih_func != NULL)) {
-			if (__predict_true((*ih->ih_func)(ih->ih_arg))) {
-				cause &= ~MIPS_INT_MASK_4;
-				/* evcnt for ICU is done in icu_intr() */
-			}
-		}
-	}
-	_splset((status & ~cause & MIPS_HARD_INT_MASK) | MIPS_SR_INT_IE);
-
-	/* software interrupt */
-	ipending &= (MIPS_SOFT_INT_MASK_1|MIPS_SOFT_INT_MASK_0);
-	if (ipending == 0)
-		return;
-
-	_clrsoftintr(ipending);
-
-	softintr_dispatch(ipending);
-}
-
-
 void
 decode_bootstring(void)
 {
Index: sys/arch/cobalt/conf/GENERIC
===================================================================
RCS file: /cvsroot/src/sys/arch/cobalt/conf/GENERIC,v
retrieving revision 1.107.2.1
diff -u -r1.107.2.1 GENERIC
--- sys/arch/cobalt/conf/GENERIC	5 Jun 2007 20:50:03 -0000	1.107.2.1
+++ sys/arch/cobalt/conf/GENERIC	2 Mar 2008 14:49:41 -0000
@@ -178,8 +178,8 @@
 ubsec*	at pci? dev ? function ?	# Broadcom 5501/5601/580x/582x
 
 # PCI serial/parallel interfaces
-#puc* 		at pci? dev ? function ? 	# PCI "universal" comm. cards
-#com* 		at puc? port ?
+puc* 		at pci? dev ? function ? 	# PCI "universal" comm. cards
+com* 		at puc? port ?
 #lpt* 		at puc? port ?
 #cy* 		at pci? dev ? function ?	# Cyclades Cyclom-Y serial cards
 
Index: sys/arch/cobalt/conf/INSTALL
===================================================================
RCS file: /cvsroot/src/sys/arch/cobalt/conf/INSTALL,v
retrieving revision 1.27
diff -u -r1.27 INSTALL
--- sys/arch/cobalt/conf/INSTALL	18 Nov 2006 14:28:55 -0000	1.27
+++ sys/arch/cobalt/conf/INSTALL	2 Mar 2008 14:49:41 -0000
@@ -165,8 +165,8 @@
 #ubsec*	at pci? dev ? function ?	# Broadcom 5501/5601/580x/582x
 
 # PCI serial/parallel interfaces
-#puc* 		at pci? dev ? function ? 	# PCI "universal" comm. cards
-#com* 		at puc? port ?
+puc* 		at pci? dev ? function ? 	# PCI "universal" comm. cards
+com* 		at puc? port ?
 #lpt* 		at puc? port ?
 #cy* 		at pci? dev ? function ?	# Cyclades Cyclom-Y serial cards
 
@@ -302,7 +302,7 @@
 #pseudo-device	vnd				# disk-like interface to files
 
 # Network pseudo-devices
-#pseudo-device	bpfilter			# Berkeley packet filter
+pseudo-device	bpfilter			# Berkeley packet filter
 #pseudo-device	ipfilter			# IP filter (firewall) and NAT
 pseudo-device	loop				# network loopback
 #pseudo-device	ppp				# Point-to-Point Protocol
Index: sys/arch/cobalt/conf/files.cobalt
===================================================================
RCS file: /cvsroot/src/sys/arch/cobalt/conf/files.cobalt,v
retrieving revision 1.28
diff -u -r1.28 files.cobalt
--- sys/arch/cobalt/conf/files.cobalt	10 Sep 2006 06:41:09 -0000	1.28
+++ sys/arch/cobalt/conf/files.cobalt	2 Mar 2008 14:49:41 -0000
@@ -39,6 +39,7 @@
 file arch/cobalt/cobalt/bus.c
 file arch/cobalt/cobalt/console.c
 file arch/cobalt/cobalt/disksubr.c
+file arch/cobalt/cobalt/interrupt.c
 file arch/cobalt/cobalt/machdep.c
 
 file arch/mips/mips/softintr.c
Index: sys/arch/cobalt/dev/com_mainbus.c
===================================================================
RCS file: /cvsroot/src/sys/arch/cobalt/dev/com_mainbus.c,v
retrieving revision 1.14
diff -u -r1.14 com_mainbus.c
--- sys/arch/cobalt/dev/com_mainbus.c	13 Jul 2006 22:56:00 -0000	1.14
+++ sys/arch/cobalt/dev/com_mainbus.c	2 Mar 2008 14:49:41 -0000
@@ -130,6 +130,6 @@
 com_mainbus_cninit(struct consdev *cn)
 {
 
-	comcnattach(0, 0x1c800000, 115200, COM_MAINBUS_FREQ, COM_TYPE_NORMAL,
+	comcnattach(0, COM_BASE, 115200, COM_MAINBUS_FREQ, COM_TYPE_NORMAL,
 	    CONMODE);
 }
Index: sys/arch/cobalt/dev/panel.c
===================================================================
RCS file: /cvsroot/src/sys/arch/cobalt/dev/panel.c,v
retrieving revision 1.10
diff -u -r1.10 panel.c
--- sys/arch/cobalt/dev/panel.c	6 Apr 2006 11:50:19 -0000	1.10
+++ sys/arch/cobalt/dev/panel.c	2 Mar 2008 14:49:41 -0000
@@ -55,6 +55,9 @@
 #define PANEL_POLLRATE	(hz / 10)
 #define PANEL_REGION	0x20
 #define DATA_OFFSET	0x10
+#define PANEL_COLS	16
+#define PANEL_VCOLS	40
+#define PANEL_ROWS	2
 
 struct panel_softc {
 	struct device sc_dev;
@@ -66,8 +69,22 @@
 	struct callout sc_callout;
 };
 
+struct lcd_message {
+	const char firstcol[PANEL_VCOLS];
+	const char secondcol[PANEL_VCOLS];
+};
+static const struct lcd_message startup_message = {
+	"NetBSD/cobalt   ",
+	"Starting up...  "
+};
+static const struct lcd_message shutdown_message = {
+	"NetBSD/cobalt   ",
+	"Shutting down..."
+};
+
 static int	panel_match(struct device *, struct cfdata *, void *);
 static void	panel_attach(struct device *, struct device *, void *);
+static void	panel_shutdown(void *);
 
 static void	panel_soft(void *);
 
@@ -103,7 +120,7 @@
 {
 	struct panel_softc *sc = (void *)self;
 	struct mainbus_attach_args *maa = aux;
-
+	struct hd44780_io io;
 	static struct lcdkp_xlate keys[] = {
 		{ 0xfa, 'h' },
 		{ 0xf6, 'k' },
@@ -123,8 +140,8 @@
 	    1, &sc->sc_lcd.sc_iodr);
 
 	sc->sc_lcd.sc_dev_ok = 1;
-	sc->sc_lcd.sc_cols = 16;
-	sc->sc_lcd.sc_vcols = 40;
+	sc->sc_lcd.sc_cols = PANEL_COLS;
+	sc->sc_lcd.sc_vcols = PANEL_VCOLS;
 	sc->sc_lcd.sc_flags = HD_8BIT | HD_MULTILINE | HD_KEYPAD;
 
 	sc->sc_lcd.sc_writereg = panel_cbt_hdwritereg;
@@ -133,8 +150,17 @@
 
 	hd44780_attach_subr(&sc->sc_lcd);
 
+	/* Hello World */
+	io.dat = 0;
+	io.len = PANEL_VCOLS * PANEL_ROWS;
+	memcpy(io.buf, &startup_message, io.len);
+	hd44780_ddram_io(&sc->sc_lcd, sc->sc_lcd.sc_curchip, &io,
+	    HD_DDRAM_WRITE);
+
+	shutdownhook_establish(panel_shutdown, sc);
+
 	sc->sc_kp.sc_iot = maa->ma_iot;
-	sc->sc_kp.sc_ioh = MIPS_PHYS_TO_KSEG1(0x1d000000); /* XXX */
+	sc->sc_kp.sc_ioh = MIPS_PHYS_TO_KSEG1(PANEL_BASE); /* XXX */
 
 	sc->sc_kp.sc_knum = sizeof(keys) / sizeof(struct lcdkp_xlate);
 	sc->sc_kp.sc_kpad = keys;
@@ -147,6 +173,20 @@
 	printf("\n");
 }
 
+static void
+panel_shutdown(void *arg)
+{
+	struct panel_softc *sc = arg;
+	struct hd44780_io io;
+
+	/* Goodbye World */
+	io.dat = 0;
+	io.len = PANEL_VCOLS * PANEL_ROWS;
+	memcpy(io.buf, &shutdown_message, io.len);
+	hd44780_ddram_io(&sc->sc_lcd, sc->sc_lcd.sc_curchip, &io,
+	    HD_DDRAM_WRITE);
+}
+
 static uint8_t
 panel_cbt_kprread(bus_space_tag_t iot, bus_space_handle_t ioh)
 {
Index: sys/arch/cobalt/include/cpu.h
===================================================================
RCS file: /cvsroot/src/sys/arch/cobalt/include/cpu.h,v
retrieving revision 1.11
diff -u -r1.11 cpu.h
--- sys/arch/cobalt/include/cpu.h	15 Apr 2006 11:28:52 -0000	1.11
+++ sys/arch/cobalt/include/cpu.h	2 Mar 2008 14:49:41 -0000
@@ -14,6 +14,18 @@
 #define COBALT_ID_QUBE2		5
 #define COBALT_ID_RAQ2		6 
 
+/*
+ * Memory map and register definitions.
+ * XXX should be elsewhere?
+ */
+#define PCIB_BASE	0x10000000
+#define GT_BASE		0x14000000
+#define LED_ADDR	0x1c000000
+#define LED_RESET	0x0f		/* Resets machine. */
+#define LED_POWEROFF	3
+#define COM_BASE	0x1c800000
+#define PANEL_BASE	0x1d000000
+
 #endif /* !_LOCORE */
 #endif /* _KERNEL */
 
Index: sys/arch/cobalt/include/intr.h
===================================================================
RCS file: /cvsroot/src/sys/arch/cobalt/include/intr.h,v
retrieving revision 1.23
diff -u -r1.23 intr.h
--- sys/arch/cobalt/include/intr.h	7 Sep 2006 03:38:55 -0000	1.23
+++ sys/arch/cobalt/include/intr.h	2 Mar 2008 14:49:42 -0000
@@ -99,26 +99,26 @@
 #define splsoftnet()	_splraise(MIPS_SOFT_INT_MASK_0|MIPS_SOFT_INT_MASK_1)
 #define splsoftserial()	_splraise(MIPS_SOFT_INT_MASK_0|MIPS_SOFT_INT_MASK_1)
 
+#define NCPU_INT	6
+#define NICU_INT	16
+
 struct cobalt_intrhand {
 	LIST_ENTRY(cobalt_intrhand) ih_q;
 	int (*ih_func)(void *);
 	void *ih_arg;
-	int ih_type;
+	int ih_irq;
 	int ih_cookie_type;
 #define	COBALT_COOKIE_TYPE_CPU	0x1
 #define	COBALT_COOKIE_TYPE_ICU	0x2
-
-	struct evcnt ih_evcnt;
-	char ih_evname[32];
 };
 
 #include <mips/softintr.h>
 
+void intr_init(void);
 void *cpu_intr_establish(int, int, int (*)(void *), void *);
 void *icu_intr_establish(int, int, int, int (*)(void *), void *);
 void cpu_intr_disestablish(void *);
 void icu_intr_disestablish(void *);
-void icu_init(void);
 
 #endif /* !_LOCORE */
 #endif /* _LOCORE */
Index: sys/arch/cobalt/pci/pci_machdep.c
===================================================================
RCS file: /cvsroot/src/sys/arch/cobalt/pci/pci_machdep.c,v
retrieving revision 1.24
diff -u -r1.24 pci_machdep.c
--- sys/arch/cobalt/pci/pci_machdep.c	22 Aug 2006 21:42:19 -0000	1.24
+++ sys/arch/cobalt/pci/pci_machdep.c	2 Mar 2008 14:49:42 -0000
@@ -1,4 +1,4 @@
-/*	$NetBSD: pci_machdep.c,v 1.24 2006/08/22 21:42:19 riz Exp $	*/
+/*	$NetBSD: pci_machdep.c,v 1.25 2007/02/18 12:22:16 tsutsui Exp $	*/
 
 /*
  * Copyright (c) 2000 Soren S. Jorvang.  All rights reserved.
@@ -26,7 +26,7 @@
  */
 
 #include <sys/cdefs.h>
-__KERNEL_RCSID(0, "$NetBSD: pci_machdep.c,v 1.24 2006/08/22 21:42:19 riz Exp $");
+__KERNEL_RCSID(0, "$NetBSD: pci_machdep.c,v 1.25 2007/02/18 12:22:16 tsutsui Exp $");
 
 #include <sys/types.h>
 #include <sys/param.h>
@@ -152,17 +152,33 @@
 	pci_decompose_tag(pc, intrtag, &bus, &dev, &func);
 
 	/*
-	 * The interrupt lines of the two Tulips are connected
+	 * The interrupt lines of the internal Tulips are connected
 	 * directly to the CPU.
 	 */
+	if (cobalt_id == COBALT_ID_QUBE2700) {
+		if (bus == 0 && dev == 7 && pin == PCI_INTERRUPT_PIN_A) {
+			/* tulip is connected to CPU INT2 on Qube2700 */
+			*ihp = NICU_INT + 2;
+			return 0;
+		}
+	} else {
+		if (bus == 0 && dev == 7 && pin == PCI_INTERRUPT_PIN_A) {
+			/* the primary tulip is connected to CPU INT1 */
+			*ihp = NICU_INT + 1;
+			return 0;
+		}
+		if (bus == 0 && dev == 12 && pin == PCI_INTERRUPT_PIN_A) {
+			/* the secondary tulip is connected to CPU INT2 */
+			*ihp = NICU_INT + 2;
+			return 0;
+		}
+	}
 
-	if (bus == 0 && dev == 7 && pin == PCI_INTERRUPT_PIN_A)
-		*ihp = 16 + 1;
-	else if (bus == 0 && dev == 12 && pin == PCI_INTERRUPT_PIN_A)
-		*ihp = 16 + 2;
-	else
-		*ihp = line;
+	/* sanity check */
+	if (line == 0 || line >= NICU_INT)
+		return -1;
 
+	*ihp = line;
 	return 0;
 }
 
@@ -171,8 +187,8 @@
 {
 	static char irqstr[8];
 
-	if (ih >= 16)
-		sprintf(irqstr, "level %d", ih - 16);
+	if (ih >= NICU_INT)
+		sprintf(irqstr, "level %d", ih - NICU_INT);
 	else
 		sprintf(irqstr, "irq %d", ih);
 
@@ -192,8 +208,8 @@
     int (*func)(void *), void *arg)
 {
 
-	if (ih >= 16)
-		return cpu_intr_establish(ih - 16, level, func, arg);
+	if (ih >= NICU_INT)
+		return cpu_intr_establish(ih - NICU_INT, level, func, arg);
 	else
 		return icu_intr_establish(ih, IST_LEVEL, level, func, arg);
 }
@@ -212,7 +228,12 @@
     int *iline)
 {
 
-	/* not yet... */
+	/*
+	 * Use irq 9 on all devices on the Qube's PCI slot.
+	 * XXX doesn't handle devices over PCI-PCI bridges
+	 */
+	if (bus == 0 && dev == 10 && pin != PCI_INTERRUPT_PIN_NONE)
+		*iline = 9;
 }
 
 int
Index: sys/arch/cobalt/stand/boot/Makefile
===================================================================
RCS file: /cvsroot/src/sys/arch/cobalt/stand/boot/Makefile,v
retrieving revision 1.11.6.1
diff -u -r1.11.6.1 Makefile
--- sys/arch/cobalt/stand/boot/Makefile	4 Nov 2007 16:30:54 -0000	1.11.6.1
+++ sys/arch/cobalt/stand/boot/Makefile	2 Mar 2008 14:49:42 -0000
@@ -53,7 +53,7 @@
 # -I${.CURDIR}/../.. done by Makefile.inc
 CPPFLAGS+=	-nostdinc -D_STANDALONE -DNO_ABICALLS -D_NO_PROM_DEFINES
 # CPPFLAGS+=	-D_DEBUG
-CPPFLAGS+=	-I${.OBJDIR} -I${S} -I${LIBSADIR}
+CPPFLAGS+=	-I${.OBJDIR} -I${S} -I${S}/arch -I${LIBSADIR}
 CPPFLAGS+=	-DCONS_SERIAL -DCOMBASE=${COMBASE} -DCOMPORT=${COMPORT}
 CPPFLAGS+=	-DCOMSPEED=${COMSPEED} -DCOMPROBE=${COMPROBE}
 CPPFLAGS+=	-DSUPPORT_DHCP -DSUPPORT_BOOTP
@@ -63,6 +63,10 @@
 # compiler flags for smallest code size
 CFLAGS=		-Os -mmemcpy -ffreestanding -mno-abicalls -msoft-float -G 128
 
+CFLAGS+=	-Wall -Werror
+CFLAGS+=	-Wstrict-prototypes -Wmissing-prototypes -Wpointer-arith
+CFLAGS+=	-Wno-pointer-sign
+
 NETBSD_VERS!=	${HOST_SH} ${S}/conf/osrelease.sh
 CPPFLAGS+=	-DNETBSD_VERS='"${NETBSD_VERS}"'
 
@@ -72,7 +76,7 @@
 # common sources
 SRCS+=		start.S boot.c devopen.c conf.c clock.c bootinfo.c
 SRCS+=		prf.c com.c cons.c ns16550.c pciide.c tgets.c wdc.c wd.c
-SRCS+=		cache.c nif_tlp.c tlp.c
+SRCS+=		cache.c pci.c nif_tlp.c tlp.c
 
 # XXX dev_net.c should really be in libsa, but it doesn't
 #     declare ip_convertaddr correctly.
Index: sys/arch/cobalt/stand/boot/boot.c
===================================================================
RCS file: /cvsroot/src/sys/arch/cobalt/stand/boot/boot.c,v
retrieving revision 1.5.24.2
diff -u -r1.5.24.2 boot.c
--- sys/arch/cobalt/stand/boot/boot.c	4 Nov 2007 16:30:53 -0000	1.5.24.2
+++ sys/arch/cobalt/stand/boot/boot.c	2 Mar 2008 14:49:42 -0000
@@ -83,6 +83,8 @@
 #include <sys/exec.h>
 #include <sys/exec_elf.h>
 
+#include <cobalt/dev/gtreg.h>
+
 #include "boot.h"
 #include "cons.h"
 #include "common.h"
@@ -104,6 +106,17 @@
 	NULL
 };
 
+u_int cobalt_id;
+static const char * const cobalt_model[] =
+{
+	[0]                  = "Unknown Cobalt",
+	[COBALT_ID_QUBE2700] = "Cobalt Qube 2700",
+	[COBALT_ID_RAQ]      = "Cobalt RaQ",
+	[COBALT_ID_QUBE2]    = "Cobalt Qube 2",
+	[COBALT_ID_RAQ2]     = "Cobalt RaQ 2"
+};
+#define COBALT_MODELS	__arraycount(cobalt_model)
+
 extern u_long end;		/* Boot loader code end address */
 void start(void);
 
@@ -114,6 +127,7 @@
 static int parse_bootname(char *, int, char **, char **);
 static void prominit(unsigned int memsize);
 static void print_banner(unsigned int memsize);
+static u_int read_board_id(void);
 
 void cpu_reboot(void);
 
@@ -370,10 +384,29 @@
 	printf(">> %s " NETBSD_VERS " Bootloader, Revision %s [@%p]\n",
 			bootprog_name, bootprog_rev, (void*)&start);
 	printf(">> (%s, %s)\n", bootprog_maker, bootprog_date);
+	printf(">> Model:\t\t%s\n", cobalt_model[cobalt_id]);
 	printf(">> Memory:\t\t%u k\n", (memsize - MIPS_KSEG0_START) / 1024);
 	printf(">> PROM boot string:\t%s\n", bootstring);
 }
 
+u_int
+read_board_id(void)
+{
+	uint32_t tag, reg;
+
+#define PCIB_PCI_BUS		0
+#define PCIB_PCI_DEV		9
+#define PCIB_PCI_FUNC		0
+#define PCIB_BOARD_ID_REG	0x94
+#define COBALT_BOARD_ID(reg)	((reg & 0x000000f0) >> 4)
+
+	tag = (PCIB_PCI_BUS << 16) | (PCIB_PCI_DEV << 11) |
+	    (PCIB_PCI_FUNC << 8);
+	reg = pcicfgread(tag, PCIB_BOARD_ID_REG);
+
+	return COBALT_BOARD_ID(reg);
+}
+
 /*
  * Entry point.
  * Parse PROM boot string, load the kernel and jump into it
@@ -396,10 +429,13 @@
 	try_bootp = 1;
 
 	/* Initialize boot info early */
+	dev = NULL;
+	kernel = NULL;
 	howto = 0x0;
 	bi_flags.bi_flags = 0x0;
 	bi_addr = bi_init();
 
+	cobalt_id = read_board_id();
 	prominit(memsize);
 	if (cninit(&addr, &speed) != NULL)
 		bi_flags.bi_flags |= BI_SERIAL_CONSOLE;
Index: sys/arch/cobalt/stand/boot/boot.h
===================================================================
RCS file: /cvsroot/src/sys/arch/cobalt/stand/boot/boot.h,v
retrieving revision 1.3.24.2
diff -u -r1.3.24.2 boot.h
--- sys/arch/cobalt/stand/boot/boot.h	4 Nov 2007 16:30:53 -0000	1.3.24.2
+++ sys/arch/cobalt/stand/boot/boot.h	2 Mar 2008 14:49:42 -0000
@@ -44,6 +44,11 @@
 #define DEFKERNELNAME	kernelnames[0]
 
 extern char *kernelnames[];
+extern u_int cobalt_id;
+#define COBALT_ID_QUBE2700	3
+#define COBALT_ID_RAQ		4
+#define COBALT_ID_QUBE2		5
+#define COBALT_ID_RAQ2		6 
 
 /*
  * com
@@ -97,3 +102,8 @@
 void pdcache_wb(uint32_t, u_int);
 void pdcache_inv(uint32_t, u_int);
 void pdcache_wbinv(uint32_t, u_int);
+
+/*
+ * pci
+ */
+uint32_t pcicfgread(uint32_t, uint32_t);
Index: sys/arch/cobalt/stand/boot/bootinfo.c
===================================================================
RCS file: /cvsroot/src/sys/arch/cobalt/stand/boot/bootinfo.c,v
retrieving revision 1.2.24.1
diff -u -r1.2.24.1 bootinfo.c
--- sys/arch/cobalt/stand/boot/bootinfo.c	28 Aug 2007 19:27:03 -0000	1.2.24.1
+++ sys/arch/cobalt/stand/boot/bootinfo.c	2 Mar 2008 14:49:42 -0000
@@ -85,5 +85,7 @@
 
 		bi = (struct btinfo_common *)bi_next;
 		bi->next = bi->type = 0;
+
+		bi_size += size;
 	}
 }
Index: sys/arch/cobalt/stand/boot/com.c
===================================================================
RCS file: /cvsroot/src/sys/arch/cobalt/stand/boot/com.c,v
retrieving revision 1.4.24.1
diff -u -r1.4.24.1 com.c
--- sys/arch/cobalt/stand/boot/com.c	28 Aug 2007 19:27:02 -0000	1.4.24.1
+++ sys/arch/cobalt/stand/boot/com.c	2 Mar 2008 14:49:42 -0000
@@ -65,6 +65,8 @@
  */
 
 #include <sys/types.h>
+#include <lib/libsa/stand.h>
+#include "boot.h"
 
 #define	COM_FREQ	1843200	/* 16-bit baud rate divisor */
 #define	COM_TOLERANCE	30	/* baud rate tolerance, in 0.1% units */
Index: sys/arch/cobalt/stand/boot/conf.c
===================================================================
RCS file: /cvsroot/src/sys/arch/cobalt/stand/boot/conf.c,v
retrieving revision 1.4.24.1
diff -u -r1.4.24.1 conf.c
--- sys/arch/cobalt/stand/boot/conf.c	4 Nov 2007 16:30:53 -0000	1.4.24.1
+++ sys/arch/cobalt/stand/boot/conf.c	2 Mar 2008 14:49:42 -0000
@@ -55,17 +55,18 @@
 	{ "nfs", net_strategy, net_open, net_close, net_ioctl }
 };
 
-int	ndevs = (sizeof(devsw)/sizeof(devsw[0]));
+int ndevs = __arraycount(devsw);
 
 /*
  * Filesystem configuration
  */
 struct fs_ops file_system[] = {
-	FS_OPS(ufs),
+	FS_OPS(ffsv1),
+	FS_OPS(ffsv2),
 	FS_OPS(nfs),
 };
 
-int nfsys = sizeof(file_system) / sizeof(file_system[0]);
+int nfsys = __arraycount(file_system);
 
 extern struct netif_driver en_driver;
 
@@ -73,4 +74,4 @@
 	&ether_tlp_driver,
 };
 
-int n_netif_drivers = sizeof(netif_drivers) / sizeof(netif_drivers[0]);
+int n_netif_drivers = __arraycount(netif_drivers);
Index: sys/arch/cobalt/stand/boot/cons.c
===================================================================
RCS file: /cvsroot/src/sys/arch/cobalt/stand/boot/cons.c,v
retrieving revision 1.3.24.1
diff -u -r1.3.24.1 cons.c
--- sys/arch/cobalt/stand/boot/cons.c	28 Aug 2007 19:27:04 -0000	1.3.24.1
+++ sys/arch/cobalt/stand/boot/cons.c	2 Mar 2008 14:49:42 -0000
@@ -151,7 +151,7 @@
 
 	if (cn_tab)
 		return (*cn_tab->cn_scan)(cn_tab->cn_dev);
-	return 0;
+	return -1;
 }
 
 #ifdef CONS_FB
Index: sys/arch/cobalt/stand/boot/devopen.c
===================================================================
RCS file: /cvsroot/src/sys/arch/cobalt/stand/boot/devopen.c,v
retrieving revision 1.1.54.2
diff -u -r1.1.54.2 devopen.c
--- sys/arch/cobalt/stand/boot/devopen.c	4 Nov 2007 16:30:54 -0000	1.1.54.2
+++ sys/arch/cobalt/stand/boot/devopen.c	2 Mar 2008 14:49:42 -0000
@@ -96,6 +96,7 @@
 				return EPART;
 
 			/* partition number */
+			p = 0;
 			if (i < devlen)
 				p = fname[i++] - 'a';
 
Index: sys/arch/cobalt/stand/boot/prf.c
===================================================================
RCS file: /cvsroot/src/sys/arch/cobalt/stand/boot/prf.c,v
retrieving revision 1.1.54.1
diff -u -r1.1.54.1 prf.c
--- sys/arch/cobalt/stand/boot/prf.c	28 Aug 2007 19:27:03 -0000	1.1.54.1
+++ sys/arch/cobalt/stand/boot/prf.c	2 Mar 2008 14:49:42 -0000
@@ -37,6 +37,7 @@
  */
 
 #include <lib/libsa/stand.h>
+#include "boot.h"
 
 void
 putchar(int c)
Index: sys/arch/cobalt/stand/boot/tlp.c
===================================================================
RCS file: /cvsroot/src/sys/arch/cobalt/stand/boot/tlp.c,v
retrieving revision 1.3.4.2
diff -u -r1.3.4.2 tlp.c
--- sys/arch/cobalt/stand/boot/tlp.c	4 Nov 2007 16:30:55 -0000	1.3.4.2
+++ sys/arch/cobalt/stand/boot/tlp.c	2 Mar 2008 14:49:43 -0000
@@ -72,6 +72,7 @@
 #define T1_FS		(1U<<29)	/* first segment */
 #define T1_SET		(1U<<27)	/* "setup packet" */
 #define T1_TER		(1U<<25)	/* end of ring mark */
+#define T1_TCH		(1U<<24)	/* Second address chained */
 #define T1_TBS_MASK	0x7ff		/* segment size 10:0 */
 #define R0_OWN		(1U<<31)	/* desc is empty */
 #define R0_FS		(1U<<30)	/* first desc of frame */
@@ -90,18 +91,21 @@
 #endif
 };
 
-#define TLP_BMR		0x000		/* 0: bus mode */
+#define TLP_BMR		0x00		/* 0: bus mode */
 #define  BMR_RST	(1U<< 0)	/* software reset */
-#define TLP_TPD		0x008		/* 1: instruct Tx to start */
+#define  BMR_BAR	(1U<< 1)	/* bus arbitration */
+#define  BMR_PBL8	(1U<<11)	/* burst length 8 longword */
+#define  BMR_CAL8	(1U<<13)	/* cache alignment 8 longword */
+#define TLP_TPD		0x08		/* 1: instruct Tx to start */
 #define  TPD_POLL	(1U<< 0)	/* transmit poll demand */
-#define TLP_RPD		0x010		/* 2: instruct Rx to start */
+#define TLP_RPD		0x10		/* 2: instruct Rx to start */
 #define  RPD_POLL	(1U<< 0)	/* receive poll demand */
-#define TLP_RRBA	0x018		/* 3: Rx descriptor base */
-#define TLP_TRBA	0x020		/* 4: Tx descriptor base */
-#define TLP_STS		0x028		/* 5: status */
+#define TLP_RRBA	0x18		/* 3: Rx descriptor base */
+#define TLP_TRBA	0x20		/* 4: Tx descriptor base */
+#define TLP_STS		0x28		/* 5: status */
 #define  STS_TS		0x00700000	/* Tx status */
 #define  STS_RS		0x000e0000	/* Rx status */
-#define TLP_OMR		0x030		/* 6: operation mode */
+#define TLP_OMR		0x30		/* 6: operation mode */
 #define  OMR_SDP	(1U<<25)	/* always ON */
 #define  OMR_PS		(1U<<18)	/* port select */
 #define  OMR_PM		(1U<< 6)	/* promicuous */
@@ -109,27 +113,40 @@
 #define  OMR_REN	(1U<< 1)	/* instruct start/stop Rx */
 #define  OMR_FD		(1U<< 9)	/* FDX */
 #define TLP_IEN		0x38		/* 7: interrupt enable mask */
-#define TLP_APROM	0x048		/* 9: SEEPROM and MII management */
+#define TLP_APROM	0x48		/* 9: SEEPROM and MII management */
 #define  SROM_RD	(1U <<14)	/* read operation */
 #define  SROM_WR	(1U <<13)	/* write openration */
 #define  SROM_SR	(1U <<11)	/* SEEPROM select */
 #define TLP_CSR12	0x60		/* SIA status */
 
+#define TLP_CSR13	0x68		/* SIA connectivity register */
+#define  SIACONN_10BT	0x0000ef01	/* 10BASE-T for 21041 */
+
+#define TLP_CSR14	0x70		/* SIA TX RX register */
+#define  SIATXRX_10BT	0x0000ffff	/* 10BASE-T for 21041 pass 2 */
+
 #define TLP_CSR15	0x78		/* SIA general register */
 #define  SIAGEN_MD0	(1U<<16)
 #define  SIAGEN_CWE	(1U<<28)
+#define  SIAGEN_10BT	0x00000000	/* 10BASE-T for 21041 */
+
+#define TLP_SETUP_NADDR	16
+#define TLP_SETUPLEN	192		/* 16 * 3 * sizeof(uint32_t) */
 
 #define FRAMESIZE	1536
 #define BUFSIZE		2048
+#define NTXBUF		2
+#define NEXT_TXBUF(x)	(((x) + 1) & (NTXBUF - 1))
 #define NRXBUF		2
 #define NEXT_RXBUF(x)	(((x) + 1) & (NRXBUF - 1))
 
 struct local {
-	struct desc TxD;
-	struct desc RxD[NRXBUF];
-	uint8_t txstore[BUFSIZE];
+	struct desc txd[NTXBUF];
+	struct desc rxd[NRXBUF];
+	uint8_t txstore[TLP_SETUPLEN];
 	uint8_t rxstore[NRXBUF][BUFSIZE];
 	uint32_t csr, omr;
+	u_int tx;
 	u_int rx;
 	u_int sromsft;
 	u_int phy;
@@ -150,25 +167,33 @@
 void *
 tlp_init(void *cookie)
 {
-	uint32_t val;
+	uint32_t val, tag;
 	struct local *l;
-	struct desc *TxD, *RxD;
-	uint8_t *en;
+	struct desc *txd, *rxd;
+	uint8_t *en, *p;
 	int i;
+	int is21041;
+
+	if (cobalt_id == COBALT_ID_QUBE2700)
+		is21041 = 1;
+	else
+		is21041 = 0;
 
 	l = ALLOC(struct local, CACHELINESIZE);
 	memset(l, 0, sizeof(struct local));
 
-	DPRINTF(("tlp: l = %p, TxD = %p, RxD[0] = %p, RxD[1] = %p\n",
-	    l, &l->TxD, &l->RxD[0], &l->RxD[1]));
+	DPRINTF(("tlp: l = %p, txd[0] = %p, txd[1] = %p\n",
+	    l, &l->txd[0], &l->txd[1]));
+	DPRINTF(("tlp: rxd[0] = %p, rxd[1] = %p\n",
+	    &l->rxd[0], &l->rxd[1]));
 	DPRINTF(("tlp: txstore = %p, rxstore[0] = %p, rxstore[1] = %p\n",
 	    l->txstore, l->rxstore[0], l->rxstore[1]));
 
-#if 0
+#if 1
 	/* XXX assume tlp0 at pci0 dev 7 function 0 */
 	tag = (0 << 16) | ( 7 << 11) | (0 << 8);
 	/* memory map is not initialized by the firmware on cobalt */
-	l->csr = MIPS_PHYS_TO_KSEG1(pcicfgread(tag, 0x10) & 0xfffffffc);
+	l->csr = MIPS_PHYS_TO_KSEG1(pcicfgread(tag, 0x10) & ~3U);
 	DPRINTF(("%s: CSR = 0x%x\n", __func__, l->csr));
 #else
 	l->csr = MIPS_PHYS_TO_KSEG1(COBALT_TLP0_BASE);
@@ -181,10 +206,25 @@
 	DELAY(1000);
 	(void)CSR_READ(l, TLP_BMR);
 
+	if (is21041) {
+		/* reset SIA for 10BASE-T */
+		CSR_WRITE(l, TLP_CSR13, 0);
+		DELAY(1000);
+		CSR_WRITE(l, TLP_CSR15, SIAGEN_10BT);
+		CSR_WRITE(l, TLP_CSR14, SIATXRX_10BT);
+		CSR_WRITE(l, TLP_CSR13, SIACONN_10BT);
+	} else {
+		/* reset PHY (cobalt quirk from if_tlp_pci.c) */
+		CSR_WRITE(l, TLP_CSR15, SIAGEN_CWE | SIAGEN_MD0);
+		DELAY(10);
+		CSR_WRITE(l, TLP_CSR15, SIAGEN_CWE);
+		DELAY(10);
+	}
+
 	l->omr = OMR_PS | OMR_SDP;
 	CSR_WRITE(l, TLP_OMR, l->omr);
-	CSR_WRITE(l, TLP_STS, ~0);
 	CSR_WRITE(l, TLP_IEN, 0);
+	CSR_WRITE(l, TLP_STS, ~0);
 
 #if 0
 	mii_initphy(l);
@@ -206,44 +246,58 @@
 	DPRINTF(("tlp: MAC address %x:%x:%x:%x:%x:%x\n",
 	    en[0], en[1], en[2], en[3], en[4], en[5]));
 
-	RxD = &l->RxD[0];
+	rxd = &l->rxd[0];
 	for (i = 0; i < NRXBUF; i++) {
-		RxD[i].xd3 = htole32(VTOPHYS(&RxD[NEXT_RXBUF(i)]));
-		RxD[i].xd2 = htole32(VTOPHYS(l->rxstore[i]));
-		RxD[i].xd1 = htole32(R1_RCH|FRAMESIZE);
-		RxD[i].xd0 = htole32(R0_OWN);
+		rxd[i].xd3 = htole32(VTOPHYS(&rxd[NEXT_RXBUF(i)]));
+		rxd[i].xd2 = htole32(VTOPHYS(l->rxstore[i]));
+		rxd[i].xd1 = htole32(R1_RCH|FRAMESIZE);
+		rxd[i].xd0 = htole32(R0_OWN);
 	}
-	CSR_WRITE(l, TLP_RRBA, VTOPHYS(RxD));
 
-	/* "setup packet" to have own station address */
-	TxD = &l->TxD;
-	TxD->xd3 = htole32(VTOPHYS(TxD));
-	TxD->xd2 = htole32(VTOPHYS(l->txstore));
-	TxD->xd1 = htole32(T1_SET | T1_TER);
-	TxD->xd0 = htole32(0);
-	CSR_WRITE(l, TLP_TRBA, VTOPHYS(TxD));
+	txd = &l->txd[0];
+	for (i = 0; i < NTXBUF; i++) {
+		txd[i].xd3 = htole32(VTOPHYS(&txd[NEXT_TXBUF(i)]));
+		txd[i].xd0 = htole32(0);
+	}
+
+	/* prepare setup packet */
+	p = l->txstore;
+	memset(p, 0, TLP_SETUPLEN);
+	/* put broadcast first */
+	p[0] = p[1] = p[4] = p[5] = p[8] = p[9] = 0xff;
+	for (i = 1; i < TLP_SETUP_NADDR; i++) {
+		/* put own station address to the rest */
+		p[i * 12 + 0] = en[0];
+		p[i * 12 + 1] = en[1];
+		p[i * 12 + 4] = en[2];
+		p[i * 12 + 5] = en[3];
+		p[i * 12 + 8] = en[4];
+		p[i * 12 + 9] = en[5];
+	}
 
-	memset(l->txstore, 0, FRAMESIZE);
+	txd = &l->txd[0];
+	txd->xd2 = htole32(VTOPHYS(l->txstore));
+	txd->xd1 = htole32(T1_SET | T1_TCH | TLP_SETUPLEN);
+	txd->xd0 = htole32(T0_OWN);
 
 	/* make sure the entire descriptors transfered to memory */
 	wbinv(l, sizeof(struct local));
 
+	CSR_WRITE(l, TLP_RRBA, VTOPHYS(rxd));
+	CSR_WRITE(l, TLP_TRBA, VTOPHYS(txd));
+
+	l->tx = NEXT_TXBUF(0);
 	l->rx = 0;
-	l->omr |= OMR_FD | OMR_TEN | OMR_REN;
+	l->omr |= OMR_TEN | OMR_REN;
+	if (!is21041)
+		l->omr |= OMR_FD;
 
-#if 1
-	/* reset PHY (cobalt quirk from if_tlp_pci.c) */
-	CSR_WRITE(l, TLP_CSR15, SIAGEN_CWE | SIAGEN_MD0);
-	DELAY(10);
-	CSR_WRITE(l, TLP_CSR15, SIAGEN_CWE);
-	DELAY(10);
-#endif
-	
-	/* start Tx/Rx */
+	/* enable Tx/Rx */
 	CSR_WRITE(l, TLP_OMR, l->omr);
-#if 0
+	/* start TX and send setup packet */
 	CSR_WRITE(l, TLP_TPD, TPD_POLL);
-#endif
+	DELAY(1000);
+	/* start RX */
 	CSR_WRITE(l, TLP_RPD, RPD_POLL);
 
 	return l;
@@ -253,31 +307,22 @@
 tlp_send(void *dev, char *buf, u_int len)
 {
 	struct local *l = dev;
-	struct desc *TxD;
+	struct desc *txd;
 	u_int loop;
 
-#if 1
 	wb(buf, len);
-	TxD = &l->TxD;
-	TxD->xd3 = htole32(VTOPHYS(TxD));
-	TxD->xd2 = htole32(VTOPHYS(buf));
-	TxD->xd1 = htole32(T1_FS | T1_LS | T1_TER | (len & T1_TBS_MASK));
-#else
-	memcpy(l->txstore, buf, len);
-	wb(l->txstore, len);
-	TxD = &l->TxD;
-	TxD->xd3 = htole32(VTOPHYS(TxD));
-	TxD->xd2 = htole32(VTOPHYS(l->txstore));
-	TxD->xd1 = htole32(T1_FS | T1_LS | T1_TER | (len & T1_TBS_MASK));
-#endif
-	TxD->xd0 = htole32(T0_OWN);
-	wbinv(TxD, sizeof(struct desc));
+	txd = &l->txd[l->tx];
+	txd->xd2 = htole32(VTOPHYS(buf));
+	txd->xd1 = htole32(T1_FS | T1_LS | T1_TCH | (len & T1_TBS_MASK));
+	txd->xd0 = htole32(T0_OWN);
+	wbinv(txd, sizeof(struct desc));
 	CSR_WRITE(l, TLP_TPD, TPD_POLL);
+	l->tx = NEXT_TXBUF(l->tx);
 	loop = 100;
 	do {
-		if ((le32toh(TxD->xd0) & T0_OWN) == 0)
+		if ((le32toh(txd->xd0) & T0_OWN) == 0)
 			goto done;
-		inv(TxD, sizeof(struct desc));
+		inv(txd, sizeof(struct desc));
 		DELAY(10);
 	} while (--loop > 0);
 	printf("xmit failed\n");
@@ -290,29 +335,29 @@
 tlp_recv(void *dev, char *buf, u_int maxlen, u_int timo)
 {
 	struct local *l = dev;
-	struct desc *RxD;
+	struct desc *rxd;
 	u_int bound, len;
 	uint32_t rxstat;
 	uint8_t *ptr;
 
-	bound = 1000 * timo;
+	bound = timo * 1000000;
 
   again:
-	RxD = &l->RxD[l->rx];
+	rxd = &l->rxd[l->rx];
 	do {
-		rxstat = le32toh(RxD->xd0);
-		inv(RxD, sizeof(struct desc));
+		rxstat = le32toh(rxd->xd0);
+		inv(rxd, sizeof(struct desc));
 		if ((rxstat & R0_OWN) == 0)
 			goto gotone;
-		DELAY(1000); /* 1 milli second */
+		DELAY(1);
 	} while (--bound > 0);
 	errno = 0;
 	CSR_WRITE(l, TLP_RPD, RPD_POLL);
 	return -1;
   gotone:
 	if (rxstat & R0_ES) {
-		RxD->xd0 = htole32(R0_OWN);
-		wbinv(RxD, sizeof(struct desc));
+		rxd->xd0 = htole32(R0_OWN);
+		wbinv(rxd, sizeof(struct desc));
 		l->rx = NEXT_RXBUF(l->rx);
 		CSR_WRITE(l, TLP_RPD, RPD_POLL);
 		goto again;
@@ -324,8 +369,8 @@
 	ptr = l->rxstore[l->rx];
 	memcpy(buf, ptr, len);
 	inv(ptr, FRAMESIZE);
-	RxD->xd0 = htole32(R0_OWN);
-	wbinv(RxD, sizeof(struct desc));
+	rxd->xd0 = htole32(R0_OWN);
+	wbinv(rxd, sizeof(struct desc));
 	l->rx = NEXT_RXBUF(l->rx);
 	CSR_WRITE(l, TLP_OMR, l->omr); /* necessary? */
 	return len;
Index: sys/arch/cobalt/stand/boot/version
===================================================================
RCS file: /cvsroot/src/sys/arch/cobalt/stand/boot/version,v
retrieving revision 1.1.54.3
diff -u -r1.1.54.3 version
--- sys/arch/cobalt/stand/boot/version	4 Nov 2007 16:30:54 -0000	1.1.54.3
+++ sys/arch/cobalt/stand/boot/version	2 Mar 2008 14:49:43 -0000
@@ -10,3 +10,5 @@
 0.4:	parse "root=/dev/hdXN" args passed from the firmware and
 	set default boot device accordingly
 0.5:	Add support for netboot via tlp0
+0.6:	Print a cobalt model name in banner
+0.7:	Add support for netboot via 21041 on Qube2700
Index: sys/arch/cobalt/stand/boot/wd.c
===================================================================
RCS file: /cvsroot/src/sys/arch/cobalt/stand/boot/wd.c,v
retrieving revision 1.5.24.1
diff -u -r1.5.24.1 wd.c
--- sys/arch/cobalt/stand/boot/wd.c	28 Aug 2007 19:27:03 -0000	1.5.24.1
+++ sys/arch/cobalt/stand/boot/wd.c	2 Mar 2008 14:49:43 -0000
@@ -40,6 +40,7 @@
 #include <sys/stdint.h>
 
 #include <lib/libsa/stand.h>
+#include <lib/libkern/libkern.h>
 
 #include <machine/param.h>
 #include <machine/stdarg.h>
@@ -243,12 +244,13 @@
  * Read some data.
  */
 int
-wdstrategy(void *f, int rw, daddr_t dblk, size_t size, void *buf, size_t *rsize)
+wdstrategy(void *f, int rw, daddr_t dblk, size_t size, void *p, size_t *rsize)
 {
 	int i, nsect;
 	daddr_t blkno;
 	struct wd_softc *wd;
 	struct partition *pp;
+	uint8_t *buf;
 
 	if (size == 0)
 		return 0;
@@ -256,6 +258,7 @@
 	if (rw != F_READ)
 		return EOPNOTSUPP;
 
+	buf = p;
 	wd = f;
 	pp = &wd->sc_label.d_partitions[wd->sc_part];
 
Index: sys/arch/cobalt/stand/boot/wdc.c
===================================================================
RCS file: /cvsroot/src/sys/arch/cobalt/stand/boot/wdc.c,v
retrieving revision 1.7.24.1
diff -u -r1.7.24.1 wdc.c
--- sys/arch/cobalt/stand/boot/wdc.c	28 Aug 2007 19:27:04 -0000	1.7.24.1
+++ sys/arch/cobalt/stand/boot/wdc.c	2 Mar 2008 14:49:43 -0000
@@ -118,7 +118,7 @@
 static int
 wdcprobe(struct wdc_channel *chp)
 {
-	uint8_t st0, st1, sc, sn, cl, ch;
+	uint8_t st0, st1;
 	uint8_t ret_value = 0x03;
 	uint8_t drive;
 	int found;
@@ -227,7 +227,6 @@
 int
 wdccommand(struct wd_softc *sc, struct wdc_command *wd_c)
 {
-	uint8_t err;
 	struct wdc_channel *chp = &sc->sc_channel;
 
 #if 0
@@ -264,7 +263,6 @@
 int
 wdccommandext(struct wd_softc *wd, struct wdc_command *wd_c)
 {
-	uint8_t err;
 	struct wdc_channel *chp = &wd->sc_channel;
 
 	/* Select drive, head, and addressing mode. */
Index: sys/dev/pci/pcidevs
===================================================================
RCS file: /cvsroot/src/sys/dev/pci/pcidevs,v
retrieving revision 1.855.2.16
diff -u -r1.855.2.16 pcidevs
--- sys/dev/pci/pcidevs	15 Nov 2007 10:28:24 -0000	1.855.2.16
+++ sys/dev/pci/pcidevs	2 Mar 2008 14:51:50 -0000
@@ -2368,6 +2368,7 @@
 /* IO Data products */
 product IODATA CBIDE2		0x0003	CBIDE2/CI-iCN NinjaATA-32Bi IDE
 product IODATA CBSCII		0x0005	CBSCII NinjaSCSI-32Bi SCSI
+product IODATA RSAPCI		0x0007	RSA-PCI 2-port serial
 
 /* ITE products */
 product ITE IT8152		0x8152	IT8152 Host Bridge
Index: sys/dev/pci/pcidevs.h
===================================================================
RCS file: /cvsroot/src/sys/dev/pci/pcidevs.h,v
retrieving revision 1.854.2.16
diff -u -r1.854.2.16 pcidevs.h
--- sys/dev/pci/pcidevs.h	15 Nov 2007 10:28:25 -0000	1.854.2.16
+++ sys/dev/pci/pcidevs.h	2 Mar 2008 14:51:56 -0000
@@ -1,10 +1,10 @@
-/*	$NetBSD: pcidevs.h,v 1.854.2.16 2007/11/15 10:28:25 pavel Exp $	*/
+/*	$NetBSD$	*/
 
 /*
  * THIS FILE AUTOMATICALLY GENERATED.  DO NOT EDIT.
  *
  * generated from:
- *	NetBSD
+ *	NetBSD: pcidevs,v 1.855.2.16 2007/11/15 10:28:24 pavel Exp
  */
 
 /*
@@ -2375,6 +2375,7 @@
 /* IO Data products */
 #define	PCI_PRODUCT_IODATA_CBIDE2	0x0003		/* CBIDE2/CI-iCN NinjaATA-32Bi IDE */
 #define	PCI_PRODUCT_IODATA_CBSCII	0x0005		/* CBSCII NinjaSCSI-32Bi SCSI */
+#define	PCI_PRODUCT_IODATA_RSAPCI	0x0007		/* RSA-PCI 2-port serial */
 
 /* ITE products */
 #define	PCI_PRODUCT_ITE_IT8152	0x8152		/* IT8152 Host Bridge */
Index: sys/dev/pci/pcidevs_data.h
===================================================================
RCS file: /cvsroot/src/sys/dev/pci/pcidevs_data.h,v
retrieving revision 1.853.2.16
diff -u -r1.853.2.16 pcidevs_data.h
--- sys/dev/pci/pcidevs_data.h	15 Nov 2007 10:28:26 -0000	1.853.2.16
+++ sys/dev/pci/pcidevs_data.h	2 Mar 2008 14:52:02 -0000
@@ -1,10 +1,10 @@
-/*	$NetBSD: pcidevs_data.h,v 1.853.2.16 2007/11/15 10:28:26 pavel Exp $	*/
+/*	$NetBSD$	*/
 
 /*
  * THIS FILE AUTOMATICALLY GENERATED.  DO NOT EDIT.
  *
  * generated from:
- *	NetBSD
+ *	NetBSD: pcidevs,v 1.855.2.16 2007/11/15 10:28:24 pavel Exp
  */
 
 /*
@@ -8336,6 +8336,10 @@
 	    "CBSCII NinjaSCSI-32Bi SCSI",
 	},
 	{
+	    PCI_VENDOR_IODATA, PCI_PRODUCT_IODATA_RSAPCI,
+	    "RSA-PCI 2-port serial",
+	},
+	{
 	    PCI_VENDOR_ITE, PCI_PRODUCT_ITE_IT8152,
 	    "IT8152 Host Bridge",
 	},
@@ -12888,4 +12892,4 @@
 	    "Video Controller",
 	},
 };
-const int pci_nproducts = 2627;
+const int pci_nproducts = 2628;
Index: sys/dev/pci/pucdata.c
===================================================================
RCS file: /cvsroot/src/sys/dev/pci/pucdata.c,v
retrieving revision 1.49.2.2
diff -u -r1.49.2.2 pucdata.c
--- sys/dev/pci/pucdata.c	4 Nov 2007 01:22:41 -0000	1.49.2.2
+++ sys/dev/pci/pucdata.c	2 Mar 2008 14:52:03 -0000
@@ -1223,5 +1223,15 @@
 	    },
 	},
 
+	/* I-O DATA RSA-PCI: 2S */
+	{   "I-O DATA RSA-PCI 2-port serial",
+	    {	0x10fc, 0x0007, 0, 0 },
+	    {	0xffff, 0xffff, 0, 0 },
+	    {
+		{ PUC_PORT_TYPE_COM, 0x14, 0x00, COM_FREQ },
+		{ PUC_PORT_TYPE_COM, 0x18, 0x00, COM_FREQ },
+	    },
+	},
+
 	{ .name = NULL },
 };
--- /dev/null	2008-03-12 21:56:07.000000000 +0900
+++ sys/arch/cobalt/cobalt/interrupt.c	2008-03-12 23:11:59.000000000 +0900
@@ -0,0 +1,495 @@
+/*	$NetBSD$	*/
+
+/*
+ * Copyright (c) 2006 Izumi Tsutsui.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*-
+ * Copyright (c) 2001 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by Jason R. Thorpe.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the NetBSD
+ *	Foundation, Inc. and its contributors.
+ * 4. Neither the name of The NetBSD Foundation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * Copyright (c) 2000 Soren S. Jorvang.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__KERNEL_RCSID(0, "$NetBSD$");
+
+#include <sys/param.h>
+#include <sys/malloc.h>
+
+#include <uvm/uvm_extern.h>
+
+#include <mips/mips3_clock.h>
+#include <machine/bus.h>
+#include <machine/cpu.h>
+#include <machine/intr.h>
+
+#include <dev/ic/i8259reg.h>
+#include <dev/isa/isareg.h>
+
+#include <cobalt/dev/gtreg.h>
+
+#define ICU_LEVEL	4
+#define IRQ_SLAVE	2
+
+#define IO_ELCR		0x4d0
+#define IO_ELCRSIZE	2
+#define ELCR0		0
+#define ELCR1		1
+
+#define ICU1_READ(reg)		\
+    bus_space_read_1(icu_bst, icu1_bsh, (reg))
+#define ICU1_WRITE(reg, val)	\
+    bus_space_write_1(icu_bst, icu1_bsh, (reg), (val))
+#define ICU2_READ(reg)		\
+    bus_space_read_1(icu_bst, icu2_bsh, (reg))
+#define ICU2_WRITE(reg, val)	\
+    bus_space_write_1(icu_bst, icu2_bsh, (reg), (val))
+#define ELCR_READ(reg)		\
+    bus_space_read_1(icu_bst, elcr_bsh, (reg))
+#define ELCR_WRITE(reg, val)	\
+    bus_space_write_1(icu_bst, elcr_bsh, (reg), (val))
+
+const uint32_t mips_ipl_si_to_sr[_IPL_NSOFT] = {
+	MIPS_SOFT_INT_MASK_0,			/* IPL_SOFT */
+	MIPS_SOFT_INT_MASK_0,			/* IPL_SOFTCLOCK */
+	MIPS_SOFT_INT_MASK_1,			/* IPL_SOFTNET */
+	MIPS_SOFT_INT_MASK_1,			/* IPL_SOFTSERIAL */
+};
+	
+static u_int icu_imask, icu_elcr;
+static bus_space_tag_t icu_bst;
+static bus_space_handle_t icu1_bsh, icu2_bsh, elcr_bsh;
+
+struct icu_intrhead {
+	LIST_HEAD(, cobalt_intrhand) intr_q;
+	int intr_type;
+	struct evcnt intr_evcnt;
+	char intr_evname[32];
+};
+static struct icu_intrhead icu_intrtab[NICU_INT];
+
+struct cpu_intrhead {
+	struct cobalt_intrhand intr_ih;
+	struct evcnt intr_evcnt;
+	char intr_evname[32];
+};
+static struct cpu_intrhead cpu_intrtab[NCPU_INT];
+
+static int	icu_intr(void *);
+static void	icu_set(void);
+
+void
+intr_init(void)
+{
+	int i;
+
+	/*
+	 * Initialize CPU interrupts.
+	 */
+	for (i = 0; i < NCPU_INT; i++) {
+		snprintf(cpu_intrtab[i].intr_evname,
+		    sizeof(cpu_intrtab[i].intr_evname), "int %d", i);
+		evcnt_attach_dynamic(&cpu_intrtab[i].intr_evcnt,
+		    EVCNT_TYPE_INTR, NULL, "mips", cpu_intrtab[i].intr_evname);
+	}
+
+	/*
+	 * Initialize ICU interrupts.
+	 */
+	icu_bst = 0;	/* XXX unused on cobalt */
+	bus_space_map(icu_bst, PCIB_BASE + IO_ICU1, IO_ICUSIZE, 0, &icu1_bsh);
+	bus_space_map(icu_bst, PCIB_BASE + IO_ICU2, IO_ICUSIZE, 0, &icu2_bsh);
+	bus_space_map(icu_bst, PCIB_BASE + IO_ELCR, IO_ELCRSIZE, 0, &elcr_bsh);
+
+	/* All interrupts default to "masked off". */
+	icu_imask = 0xffff;
+
+	/* All interrupts default to edge-triggered. */
+	icu_elcr = 0;
+
+	/* Initialize master PIC */
+
+	/* reset; program device, four bytes */
+	ICU1_WRITE(PIC_ICW1, ICW1_SELECT | ICW1_IC4);
+	/* starting at this vector index */
+	ICU1_WRITE(PIC_ICW2, 0);			/* XXX */
+	/* slave on line 2 */
+	ICU1_WRITE(PIC_ICW3, ICW3_CASCADE(IRQ_SLAVE));
+	/* special fully nested mode, 8086 mode */
+	ICU1_WRITE(PIC_ICW4, ICW4_SFNM | ICW4_8086);
+	/* mask all interrupts */
+	ICU1_WRITE(PIC_OCW1, icu_imask & 0xff);
+	/* special mask mode */
+	ICU1_WRITE(PIC_OCW3, OCW3_SELECT | OCW3_SSMM | OCW3_SMM);
+	/* read IRR by default */
+	ICU1_WRITE(PIC_OCW3, OCW3_SELECT | OCW3_RR);
+
+	/* Initialize slave PIC */
+
+	/* reset; program device, four bytes */
+	ICU2_WRITE(PIC_ICW1, ICW1_SELECT | ICW1_IC4);
+	/* starting at this vector index */
+	ICU2_WRITE(PIC_ICW2, 8);			/* XXX */
+	/* slave connected to line 2 of master */
+	ICU2_WRITE(PIC_ICW3, ICW3_SIC(IRQ_SLAVE));
+	/* special fully nested mode, 8086 mode */
+	ICU2_WRITE(PIC_ICW4, ICW4_SFNM | ICW4_8086);
+	/* mask all interrupts */
+	ICU1_WRITE(PIC_OCW1, (icu_imask >> 8) & 0xff);
+	/* special mask mode */
+	ICU2_WRITE(PIC_OCW3, OCW3_SELECT | OCW3_SSMM | OCW3_SMM);
+	/* read IRR by default */
+	ICU2_WRITE(PIC_OCW3, OCW3_SELECT | OCW3_RR);
+
+	/* default to edge-triggered */
+	ELCR_WRITE(ELCR0, icu_elcr & 0xff);
+	ELCR_WRITE(ELCR1, (icu_elcr >> 8) & 0xff);
+
+	wbflush();
+
+	/* Initialize our interrupt table. */
+	for (i = 0; i < NICU_INT; i++) {
+		LIST_INIT(&icu_intrtab[i].intr_q);
+		snprintf(icu_intrtab[i].intr_evname,
+		    sizeof(icu_intrtab[i].intr_evname), "irq %d", i);
+		evcnt_attach_dynamic(&icu_intrtab[i].intr_evcnt,
+		    EVCNT_TYPE_INTR, &cpu_intrtab[ICU_LEVEL].intr_evcnt,
+		    "icu", icu_intrtab[i].intr_evname);
+		icu_intrtab[i].intr_type = IST_NONE;
+	}
+
+	cpu_intr_establish(ICU_LEVEL, IPL_NONE, icu_intr, NULL);
+}
+
+void *
+icu_intr_establish(int irq, int type, int ipl, int (*func)(void *),
+    void *arg)
+{
+	struct cobalt_intrhand *ih;
+	int s;
+
+	if (irq >= NICU_INT || irq == IRQ_SLAVE || type == IST_NONE)
+		panic("%s: bad irq or type", __func__);
+
+	switch (icu_intrtab[irq].intr_type) {
+	case IST_NONE:
+		icu_intrtab[irq].intr_type = type;
+		break;
+
+	case IST_EDGE:
+	case IST_LEVEL:
+		if (type == icu_intrtab[irq].intr_type)
+			break;
+		/* FALLTHROUGH */
+	case IST_PULSE:
+		/*
+		 * We can't share interrupts in this case.
+		 */
+		return NULL;
+	}
+
+	ih = malloc(sizeof(*ih), M_DEVBUF, M_NOWAIT);
+	if (ih == NULL)
+		return NULL;
+
+	ih->ih_func = func;
+	ih->ih_arg = arg;
+	ih->ih_irq = irq;
+	ih->ih_cookie_type = COBALT_COOKIE_TYPE_ICU;
+
+	s = splhigh();
+
+	/* Insert the handler into the table. */
+	LIST_INSERT_HEAD(&icu_intrtab[irq].intr_q, ih, ih_q);
+
+	/* Enable it, set trigger mode. */
+	icu_imask &= ~(1U << irq);
+	if (icu_intrtab[irq].intr_type == IST_LEVEL)
+		icu_elcr |= (1U << irq);
+	else
+		icu_elcr &= ~(1U << irq);
+
+	icu_set();
+
+	splx(s);
+
+	return ih;
+}
+
+void
+icu_intr_disestablish(void *cookie)
+{
+	struct cobalt_intrhand *ih = cookie;
+	int s;
+
+	if (ih->ih_cookie_type == COBALT_COOKIE_TYPE_ICU) {
+		s = splhigh();
+
+		LIST_REMOVE(ih, ih_q);
+
+		if (LIST_FIRST(&icu_intrtab[ih->ih_irq].intr_q) == NULL) {
+			icu_imask |= (1U << ih->ih_irq);
+			icu_set();
+		}
+		splx(s);
+		free(ih, M_DEVBUF);
+	}
+}
+
+void
+icu_set(void)
+{
+
+	if ((icu_imask & 0xff00) != 0xff00)
+		icu_imask &= ~(1U << IRQ_SLAVE);
+	else
+		icu_imask |= (1U << IRQ_SLAVE);
+
+	ICU1_WRITE(PIC_OCW1, icu_imask);
+	ICU2_WRITE(PIC_OCW1, icu_imask >> 8);
+
+	ELCR_WRITE(ELCR0, icu_elcr);
+	ELCR_WRITE(ELCR1, icu_elcr >> 8);
+}
+
+int
+icu_intr(void *arg)
+{
+	struct cobalt_intrhand *ih;
+	int irq, handled;
+
+	handled = 0;
+
+	for (;;) {
+		/* check requested irq */
+		ICU1_WRITE(PIC_OCW3, OCW3_SELECT | OCW3_POLL);
+		irq = ICU1_READ(PIC_OCW3);
+		if ((irq & OCW3_POLL_PENDING) == 0)
+			return handled;
+
+		irq = OCW3_POLL_IRQ(irq);
+		if (irq == IRQ_SLAVE) {
+			ICU2_WRITE(PIC_OCW3, OCW3_SELECT | OCW3_POLL);
+			irq = OCW3_POLL_IRQ(ICU2_READ(PIC_OCW3)) + 8;
+		}
+
+		icu_intrtab[irq].intr_evcnt.ev_count++;
+		LIST_FOREACH(ih, &icu_intrtab[irq].intr_q, ih_q) {
+			if (__predict_false(ih->ih_func == NULL))
+				printf("%s: spurious interrupt (irq = %d)\n",
+				    __func__, irq);
+			else if (__predict_true((*ih->ih_func)(ih->ih_arg))) {
+				handled = 1;
+			}
+		}
+
+		/* issue EOI to ack */
+		if (irq >= 8) {
+			ICU2_WRITE(PIC_OCW2,
+			    OCW2_SELECT | OCW2_SL | OCW2_EOI |
+			    OCW2_ILS(irq - 8));
+			irq = IRQ_SLAVE;
+		}
+		ICU1_WRITE(PIC_OCW2,
+		    OCW2_SELECT | OCW2_SL | OCW2_EOI | OCW2_ILS(irq));
+	}
+}
+
+void *
+cpu_intr_establish(int level, int ipl, int (*func)(void *), void *arg)
+{
+	struct cobalt_intrhand *ih;
+
+	if (level < 0 || level >= NCPU_INT)
+		panic("invalid interrupt level");
+
+	ih = &cpu_intrtab[level].intr_ih;
+
+	if (ih->ih_func != NULL)
+		panic("cannot share CPU interrupts");
+
+	ih->ih_cookie_type = COBALT_COOKIE_TYPE_CPU;
+	ih->ih_func = func;
+	ih->ih_arg = arg;
+	ih->ih_irq = NICU_INT + level;
+
+	return ih;
+}
+
+void
+cpu_intr_disestablish(void *cookie)
+{
+	struct cobalt_intrhand *ih = cookie;
+
+	if (ih->ih_cookie_type == COBALT_COOKIE_TYPE_CPU) {
+		ih->ih_func = NULL;
+		ih->ih_arg = NULL;
+		ih->ih_cookie_type = 0;
+	}
+}
+
+void
+cpu_intr(uint32_t status, uint32_t cause, uint32_t pc, uint32_t ipending)
+{
+	struct clockframe cf;
+	struct cobalt_intrhand *ih;
+	uint32_t handled;
+
+	handled = 0;
+	uvmexp.intrs++;
+
+	if (ipending & MIPS_INT_MASK_5) {
+		/* call the common MIPS3 clock interrupt handler */
+		cf.pc = pc;
+		cf.sr = status;
+		mips3_clockintr(&cf);
+
+		handled |= MIPS_INT_MASK_5;
+	}
+	_splset((status & MIPS_INT_MASK_5) | MIPS_SR_INT_IE);
+
+	if (__predict_false(ipending & MIPS_INT_MASK_0)) {
+		/* GT64x11 timer0 */
+		volatile uint32_t *irq_src =
+		    (uint32_t *)MIPS_PHYS_TO_KSEG1(GT_BASE + GT_INTR_CAUSE);
+
+		if (__predict_true((*irq_src & T0EXP) != 0)) {
+			/* GT64x11 timer is no longer used for hardclock(9) */
+			*irq_src = 0;
+		}
+		handled |= MIPS_INT_MASK_0;
+	}
+	_splset((status & handled) | MIPS_SR_INT_IE);
+
+	if (ipending & MIPS_INT_MASK_3) {
+		/* 16650 serial */
+		ih = &cpu_intrtab[3].intr_ih;
+		if (__predict_true(ih->ih_func != NULL)) {
+			if (__predict_true((*ih->ih_func)(ih->ih_arg))) {
+				cpu_intrtab[3].intr_evcnt.ev_count++;
+			}
+		}
+		handled |= MIPS_INT_MASK_3;
+	}
+	_splset((status & handled) | MIPS_SR_INT_IE);
+
+	if (ipending & MIPS_INT_MASK_1) {
+		/* tulip primary */
+		ih = &cpu_intrtab[1].intr_ih;
+		if (__predict_true(ih->ih_func != NULL)) {
+			if (__predict_true((*ih->ih_func)(ih->ih_arg))) {
+				cpu_intrtab[1].intr_evcnt.ev_count++;
+			}
+		}
+		handled |= MIPS_INT_MASK_1;
+	}
+	if (ipending & MIPS_INT_MASK_2) {
+		/* tulip secondary */
+		ih = &cpu_intrtab[2].intr_ih;
+		if (__predict_true(ih->ih_func != NULL)) {
+			if (__predict_true((*ih->ih_func)(ih->ih_arg))) {
+				cpu_intrtab[2].intr_evcnt.ev_count++;
+			}
+		}
+		cause &= ~MIPS_INT_MASK_2;
+	}
+	_splset((status & handled) | MIPS_SR_INT_IE);
+
+	if (ipending & MIPS_INT_MASK_4) {
+		/* ICU interrupts */
+		ih = &cpu_intrtab[4].intr_ih;
+		if (__predict_true(ih->ih_func != NULL)) {
+			if (__predict_true((*ih->ih_func)(ih->ih_arg))) {
+				cpu_intrtab[4].intr_evcnt.ev_count++;
+			}
+		}
+		handled |= MIPS_INT_MASK_4;
+	}
+	cause &= ~handled;
+	_splset((status & ~cause & MIPS_HARD_INT_MASK) | MIPS_SR_INT_IE);
+
+	/* software interrupt */
+	ipending &= (MIPS_SOFT_INT_MASK_1|MIPS_SOFT_INT_MASK_0);
+	if (ipending == 0)
+		return;
+	_clrsoftintr(ipending);
+	softintr_dispatch(ipending);
+}
--- /dev/null	2008-03-02 23:35:42.000000000 +0900
+++ sys/arch/cobalt/stand/boot/pci.c	2008-03-02 23:02:55.000000000 +0900
@@ -0,0 +1,55 @@
+/*	$NetBSD: pci.c,v 1.1 2008/03/01 18:13:02 tsutsui Exp $	*/
+
+/*
+ * Copyright (c) 2008 Izumi Tsutsui.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <sys/param.h>
+
+#include <lib/libsa/stand.h>
+#include <lib/libkern/libkern.h>
+
+#include <mips/cpuregs.h>
+#include <cobalt/dev/gtreg.h>
+
+#include "boot.h"
+
+#define GT_BASE		0x14000000
+
+uint32_t
+pcicfgread(uint32_t tag, uint32_t off)
+{
+	uint32_t reg;
+	volatile uint32_t *pcicfg_addr, *pcicfg_data;
+
+	pcicfg_addr = (uint32_t *)MIPS_PHYS_TO_KSEG1(GT_BASE + GT_PCICFG_ADDR);
+	pcicfg_data = (uint32_t *)MIPS_PHYS_TO_KSEG1(GT_BASE + GT_PCICFG_DATA);
+
+	*pcicfg_addr = PCICFG_ENABLE | tag | (off & ~3U);
+	reg = *pcicfg_data;
+	*pcicfg_addr = 0;
+
+	return reg;
+}
